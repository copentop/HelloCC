## Linux C编程一站式学习



### 程序和编程语言


	程序（Program）是一个精确说明如何进行计算的指令序列。


程序由一系列指令（Instruction）组成，指令是指示计算机做某种运算的命令，通常包括以下几类：

输入（Input）

	从键盘、文件或者其它设备获取数据。

输出（Output）

	把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。

基本运算

	执行最基本的数学运算（加减乘除）和数据存取，其实输入和输出也属于数据存取。

测试和分支（Branch）

	测试某个条件，然后根据不同的测试结果执行不同的后续指令。

循环（Loop）

	重复执行一系列操作。


编写程序可以说就是这样一个过程：

把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。





### 常量、变量和表达式

常量（Constant）是程序中最基本的元素，有字符常量（Character Constant）、数字常量和枚举常量。



字符常量要用单引号括起来，注意单引号只能括一个字符而不能像双引号那样括一串字符，字符常量也可以是一个转义序列。



变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value），存储的值是可以随时变的，正因为变量的值可以随时变所以才叫变量。

即通过变量名就可以访问这块内存空间的内容。


变量的类型决定了它所占的存储空间的大小。


C语言规定了一些单词不允许用作标识符，这些单词称为关键字（Keyword）或保留字（Reserved Word）。

C99规定的关键字有：

	auto  break  case  char  const  continue  default  do  double
	else  enum  extern  float  for  goto  if  inline  int  long
	register  restrict  return  short  signed  sizeof  static  struct  switch  typedef
	union  unsigned  void  volatile  while  _Bool  _Complex  _Imaginary



一般来说应避免使用以下划线开头的标识符，以下划线开头的标识符只要不和C语言关键字冲突的都是合法的，
但是往往被编译器用作一些功能扩展，C语言库的实现也定义了很多以下划线开头的名字，很容易造成名字冲突。




赋值

	定义了变量之后，我们要把值存到它们的存储空间里，可以用赋值（Assignment）语句实现。


** 变量一定要先定义再使用 **


定义一个变量，就是分配一块存储空间并给它命名；

给一个变量赋值，就是把一个值存到了这块存储空间中。

变量的定义和赋值也可以一步完成，这称为变量的初始化（Initialization）。

初始化是一种特殊的变量定义语句，而不是一种赋值语句。


表达式

常量和变量之间可以做加减乘除运算，例如1+1、hour-1等。

这里的+-*/称为运算符（Operator）。

参与运算的变量和常量称为操作数（Operand）。

由运算符和操作数所组成的算式称为表达式（Expression）。


对于同一优先级的运算从左到右计算。

事实上赋值语句就是一种表达式语句，因为等号也是一种运算符。


常量可以赋值给变量，也可以和变量、运算符一起组成表达式，最简单的表达式由单个常量或变量组成，任何表达式都有一个值，表达式可以加个;号构成表达式`语句`。


C语言规定了一组语法规则，只要符合它的规则，就可以写出任意复杂的组合。

所以才可以用简单的常量、变量、表达式、语句搭建出任意复杂的程序。




等号左边表示存储位置，称为左值（lvalue）。

等号右边表示要存储的值，可以是任意组合的表达式，所以通常所说的表达式的值也称为右值（rvalue）。


### 字符类型与字符编码

计算机之所以能处理符号，是因为符号在计算机内部也用数字来表示，每个字符在计算机内部都用一个整数来表示，称为字符编码（Character Encoding）。

char型本质上就是整数，只不过取值范围比int型小，可以把char型和int型统称为整数类型（Integer Type）或简称整型。




自定义函数

定义的语法：
```
返回值类型 函数名(参数列表)
{
	语句列表
}
```


函数声明、函数定义、函数原型（Prototype）:

声明了一个函数的名字、参数类型和个数、返回值类型，这称为函数原型。

在代码中可以单独写一个函数原型，后面加;号结束，而不写函数体。

只有带函数体的声明才叫定义。

只有分配存储空间的变量声明才叫变量定义，其实函数也是一样，编译器只有见到函数定义才会生成指令，而指令在程序运行时当然也是要占存储空间的。

函数原型必须出现在函数调用之前，这也是遵循“先声明后使用”的原则。


函数的隐式声明（Implicit Declaration）

隐式声明的参数类型和个数根据函数调用代码来确定，隐式声明的返回值类型总是int。

如果编译器调用了某个函数时并没有声明它，则编译器认为此处隐式声明了，但编译对比函数原型的参数或返回值不一致时，会出现执行警告。




形参和实参

基本原理：** 形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化。**


局部变量与全局变量

把函数中定义的变量称为局部变量（Local Variable），由于形参相当于函数中定义的变量，所以形参也相当于局部变量。

'局部'理解为：

+ 某个函数中定义的变量不能被另一个函数使用。即局限于定义函数的内部。

+ 每次调用函数时局部变量都表示不同的存储空间。局部变量是在每次函数调用时分配存储空间，每次函数返回时释放存储空间的。
 
	即临时分配一个存储空间，用后就释放空间。碰巧有可能两次分配之间是同一个临时空间，局部变量最好是初始化再用。


与局部变量的概念相对的是全局变量（Global Variable）


全局变量定义在所有的函数体之外，它们在整个程序开始之前分配存储空间，在程序结束时释放存储空间，所有函数都可以通过全局变量名访问它们。

局部变量可以用任意类型相符的表达式来初始化，而全局变量只能用常量表达式初始化。


全局变量pi这样初始化是合法的：
```
double pi = 3.14 + 0.0016;
```

但这样初始化是不合法的：
```
double pi = acos(-1.0);
```

全局变量的初始值要求保存在编译生成的目标代码中，所以必须在编译时就能计算出来。

然而上面第二种Initializer的值必须在生成了目标代码之后在运行时调用acos函数才能知道，所以不能用来初始化全局变量。



C语言从语法上规定了全局变量只能用常量表达式来初始化。



如果全局变量在定义时不初始化，则初始值是0，也就是说，整型的就是0，字符型的就是'\0'，浮点型的就是0.0。

如果局部变量在定义时不初始化，则初始值是不确定的，所以，** 局部变量在使用前一定要先赋值，不管是通过初始化还是赋值运算符。**



验证局部变量存储空间的分配和释放:
```
#include <stdio.h>

int foo(void)
{
	int i;
	printf("%d\n", i);
	i = 777;
}

int main(int argc, char *argv[])
{
	foo();
	// printf("hello\n");
	foo();
	return 0;
}
```
输出结果：

	134518128
	777

** 局部变量在定义时不初始化，则初始值是不确定的。 **



### 分支语句


除了从前到后顺序执行之外，有时候我们需要检查一个条件，然后根据检查的结果执行不同的后续代码，在C语言中可以用分支语句（Selection Statement）实现。


如果表达式所表示的比较关系成立则值为真（True），否则为假（False），在C语言中分别用1和0表示。

if语句

if语句的格式为：
```
if (控制表达式)
	语句
```

if/else语句的格式为
```
if (控制表达式)
	语句
else
	语句
```


switch语句
switch语句可以产生具有多个分支的控制流程。它的格式是：
```
switch(控制表达式) {
	case 常量表达式：语句序列
	case 常量表达式：语句序列
	default：语句序列
}
```

case后面跟的必须是常量表达式，这个值必须在编译时计算出来。


case后面跟的常量表达式的值必须是可以精确比较的整型或字符型。


通常每个case后面都要加上break语句，表示退出case检测，如果没有break打断，会继续检测下面的case是否符合执行直到退出。


### 理解函数

在有返回值的函数中，return语句的作用是提供整个函数的返回值，并结束当前函数的执行。在没有返回值的函数中也可以使用return语句。


基本原理：** 函数返回一个值相当于定义一个和函数返回值类型相同的临时变量并用return后面的表达式来初始化。**


函数的返回值不是左值，不能赋值给函数的调用。


在写带有return语句的函数时要小心检查所有的代码路径（Code Path）。

有些代码路径在任何条件下都执行不到，这称为Dead Code。


### 递归

如果定义一个概念需要用到这个概念本身，我们称它的定义是递归的（Recursive）。


数学上确实有很多概念是用它自己来定义的，比如n的阶乘（Factorial）是这样定义的：n的阶乘等于n乘以n-1的阶乘。

n-1的阶乘又是什么？是n-1乘以n-2的阶乘。那n-2的阶乘呢？这样下去永远也没完。

因此需要定义一个最关键的基础条件（Base Case）：0的阶乘等于1。


写递归函数时一定要记得写Base Case，否则即使递推关系正确，整个函数也不正确。


### 循环语句

while语句
格式：
```
while (控制条件) {
	语句
}
```

do/while语句

格式：
```
do
	语句
while(控制表达式);
```


for语句
格式为
```
for(控制表达式1;控制表达式2;控制表达式3)
	语句

// 等价下面的while语句
控制表达式1;
while(控制表达式2) {
	语句
	控制表达式3;
}

```


C99引入一种新的for循环，规定控制表达式1的位置可以有变量定义。


break和continue语句

break语句的一种用法，用来跳出switch语句块，这个语句也可以用来跳出循环体。

continue语句也用来终止当前循环，和break语句不同的是，continue语句终止当前循环后又回到循环体的开头准备再次执行循环体。



嵌套循环


goto语句


goto语句，实现无条件跳转。

唯一的限制是goto只能跳到同一个函数的某个标号处，而不能跳到别的函数里。

标号（Label），给标号起名字也遵循标识符的命名规则。

格式：
```
...
goto 标号;

...

标号:

...

```

通常goto语句只用于在函数末尾做出错处理（例如释放先前分配的资源、恢复先前改动过的全局变量等），函数中任何地方出现了错误条件都可以立即跳到函数末尾，处理完之后函数返回。



### 结构体

大多数数据类型都具有单一的值，例如整数、字符、布尔值、浮点数，这些可称为基本数据类型（Primitive Type）。


由基本类型组成的数据类型称为复合数据类型（Compound Type）。


复合数据类型一方面可以从整体上当作一个数据使用，另一方面也可以分别访问它的各组成单元，复合数据类型的这种两面性提供了一种数据抽象（Data Abstraction）的方法。



定义struct 类型：

```
struct 标识符 {
	基本类型定义
	...
}
```
struct 后面的标识符在C语言中称为Tag 。

`struct Tag { ... }` 整个可以看作一个类型名，就像int或double一样。

可以先声明一个新的类型，再声明变量；也可以在声明新类型同时声明该类型的变量。

```
struct complex_struct {
	double x, y;
} z1, z2;

//
struct complex_struct z3, z4;

```
Tag也可以定义在函数外面，就像全局变量一样，这样定义的Tag在其定义之后的各函数中都可以使用。

结构体变量也可以在定义时初始化:

```
struct complex_struct { double x, y; } z;

z.x = 1.0;
z.y = 4.0;

// 定义时初始化
struct complex_struct z = { 3.0, 4.0 };

double x = 3.0;
struct complex_struct z1 = { x, 4.0, }; /* z1.x=3.0, z1.y=4.0 */
struct complex_struct z2 = { 3.0, }; /* z2.x=3.0, z2.y=0.0 */
struct complex_struct z3 = { }; /* z3.x=0.0, z3.y=0.0 */
```


枚举类型：

enum关键字的作用和struct关键字类似。

enum Tag 表示一个枚举（Enumeration）类型。

枚举类型的成员是常量，它们的值编译器自动分配。

默认第一个常量值为0 ，后续的加1；如果不希望从0开始分配，可以指定第一个常量值。

```
enum gender { MAN, WOMAN};

// 
enum gender {MAN=1, WOMAN};

```

有一点需要注意，结构体的成员名和变量名不在同一命名空间，但枚举的成员名和变量名却在同一命名空间，所以会出现命名冲突。

```
int main(void)
{
	enum coordinate_type { RECTANGULAR = 1, POLAR };
	int RECTANGULAR; // 冲突

	printf("%d %d\n", RECTANGULAR, POLAR);
	return 0;
}

```



嵌套结构体

结构体也是一种递归定义：结构体由数据类型定义，因为结构体的成员具有数据类型，而数据类型由结构体定义，因为结构体本身也是一种数据类型。

换句话说，结构体也可以嵌套。

```
struct Segment {
	struct complex_struct start;
	struct complex_struct end;
};

struct Segment s = {{ 1.0, 2.0 }, { 4.0, 6.0 }};


s.start.a = 1.0;
s.start.b = 2.0;


```

### 数组

和结构体类似，数组（Array）也是一种复合数据类型，它由一系列相同类型的元素（Element）组成。


结构体的成员可以是基本数据类型，也可以是复合数据类型，数组中的元素也是如此。

根据组合规则，我们可以定义一个由4个结构体元素组成的数组：

```
struct Complex {
	double x, y;
} a[4];

```
数组类型的长度应该用一个常量表达式来指定，而且这个常量表达式的值必须是整数类型的。

如果定义数组的同时初始化它，也可以不指定数组的长度
```
int count[] = { 3, 2, 1 };
```
编译器会根据Initializer有三个元素确定数组的长度为3。

数组和结构体虽然有很多相似之处，但也有一个显著的不同：** 数组不能互相赋值 **。

a = b这个表达式，a和b都是数组类型的变量，但是b做右值使用，自动转换成指针类型，而左边仍是数组类型，

所以编译器报的错误信息是error: incompatible types in assignment。



既然不能互相赋值，也就不能用数组类型作为函数的参数或返回值。

对于数组类型有一条特殊规则：** 数组名做右值使用时，自动转换成指向数组首元素的指针。**


```
void foo(int a[5])
{
	...
}
```
此处函数调用其实是传一个指针类型的参数，而不是数组类型的参数。




`define不仅用于定义常量，也可以定义更复杂的语法结构，称为宏（Macro）定义。define定义是在预处理阶段处理的，而枚举是在编译阶段处理的。`


字符串

字符串可以看作一个数组，它的元素是字符型的。

字符串末尾有一个字符'\0'表示字符串结束。
这里的\0是ASCII码的八进制表示，也就是ASCII码为0的那个字符。

在本书中字符串这个概念指的是以'\0'结尾的一串字符，可能是像str这种数组，也可能是像"Hello"这种字符串字面值。

字符串字面值是只读的，不允许修改。

字符串字面值还有一点和数组名类似，做右值使用时自动转换成指向首元素的指针。

数组可以像结构体一样初始化，如果是字符数组，也可以用一个字符串字面值来初始化：
```
char str[10] = "Hello";

// 相当于
char str[10] = { 'H', 'e', 'l', 'l', 'o', '\0' };

```
str的后四个元素没有指定，自动初始化为0，即'\0'字符。


如果要用一个字符串字面值准确地初始化一个字符数组，最好的办法是不指定数组的长度，而让编译器自动计算。
```
char str[] = "Hello, world.\n";
```
字符串字面值的长度包括'\0'在内一共15个字符，编译器会确定数组str的长度为15。

字符串易错的地方

字符串可以保存在一个数组里面，用%s来打印就很有必要了：
```
printf("string: %s\n", str);
```

printf会从数组str的开头一直打印到'\0'字符为止（'\0'本身不打印）。

如果数组str中没有'\0'，那么printf就会打印出界，后果和前面讲的数组访问越界一样诡异。

有时候打印出乱码，有时候看起来没错误，有时候引起程序崩溃。


多维数组

数组也可以嵌套，一个数组的元素可以是另外一个数组，这样就构成了多维数组（Multi-dimensional Array）。

```
int a[3][2] = { 1, 2, 3, 4, 5 };

```

数组a有3个元素，a[0]、a[1]、a[2]。每个元素也是一个数组，

例如a[0]是一个数组，它有两个元素a[0][0]、a[0][1]，这两个元素的类型是int，值分别是1、2。


从物理模型上看，这六个元素在存储器中仍然是连续存储的，就像一维数组一样，

相当于把概念模型的表格一行一行接起来拼成一串，C语言的这种存储方式称为Row-major方式；

而有些编程语言（例如FORTRAN）是把概念模型的表格一列一列接起来拼起一串存储的，称为Column-major方式。

多维数组也可以像嵌套结构体一样，用嵌套Initializer初始化，例如上面的二维数组也可以这样初始化：
```
int a[][2] = { { 1, 2 },
		{ 3, 4 },
		{ 5, } };

```
** 除了第一维的长度可以由编译器自动计算而不需要指定，其余各维都必须明确指定长度。**


如果是字符数组，也可以嵌套使用字符串字面值做Initializer:
```
char days[8][10] = { "", "Monday", "Tuesday",
			     "Wednesday", "Thursday", "Friday",
			     "Saturday", "Sunday" };
```



### 编码风格

C语言的语法对编码风格并没有要求，空格、Tab和换行都可以自己随意写，实现同样功能的代码可以写得很好看，也可以写得很难看。


1. 较长的字符串可以断成多个字符串然后分行书写
```
// 第一行结束不能有空白符
printf("This is such a long sentence that "
       "it cannot be held within a line\n");
```
C编译器会自动把相邻的多个字符串接在一起。
以上两个字符串相当于一个字符串"This is such a long sentence that it cannot be held within a line\n"。









